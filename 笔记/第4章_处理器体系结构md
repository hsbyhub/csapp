## 第4章_处理器体系结构

[TOC]



------



不同的处理器家族有不同的**指令集架构**(  **Instruction-Set Architecture, ISA** )。

如**Intel IA32、x86_64、IBM/Freescale Power 和ARM处理器家族**

------



### 4.1 Y86_64 指令集体系结构



#### 程序员可见的状态

![](img/2020-04-28_233313.png)



#### Y86_64指令



![](img/2020-04-28_234624.png)



#### 指令编码

指令类型的高4位表示代码部分，低4位表示功能部分

功能值只有在一组指令公用一个代码时才有用



**RISC 和 CISC 指令集**



CISC又称 “复杂指令集计算机”，比较先出现



RISC称为 “精简指令集计算机”



#### 一些 Y86-64 指令的详情



x86_64 在压栈时，先将目标压入栈指针后退后的位置，再扩展栈顶指针

出栈时，先调整栈顶指针，再将原本的内存空间的值写进目标



比如 %rsp 的值为0，push %rsp, pop %rax, 那么%rax 的值为0;

如果%rax = 999, push %rax, pop %rsp ，此时%rsp的值为999。





### 4.2 逻辑设计和硬件控制语言HCL



#### 逻辑门



#### 组合电路和HCL布尔表达式



一对输入a， b 经过异或电路和相等电路的结果互为补集

例如 eq = ( a && b ) || ( ~a && ~b )

则 xor = ~eq = ~( ( a && b ) || ( ~a && ~b ) ) =  ~( a && b ) && ( a || b )



#### 字级组合电路和HCL整数表达式

![](img/2020-04-29_201228.png)

对整数的位级对比结果进行与操作，得到最终结果





#### 集合关系



#### 存储器和时钟

![](img/2020-04-29_213524.png)





### Y86-64 的顺序实现



![](img/2020-04-29_221155.png)



![](img/2020-04-29_225509.png)



![](img/2020-04-29_225518.png)

![](img/2020-04-29_225533.png)

![](img/2020-04-29_225547.png)





#### SEQ 硬件结构



![](img/2020-04-30_104031.png)



- **取指**， 将程序计数器寄存器作为地址，指令内存读取指令的字节。然后PC增加器计算增加了的地址
- **译码**，寄存器文件有两个读端口A 和 B，从这两个端口同时读取valA 和 valB
- **执行**，执行阶段会根据指令的不同，执行不同指定的运算，并设置条件码，个别指令不会设置条件码，如leap，not，或者根据条件码，判断是否执行动作，比如条件传送和条件跳转
- **访存**， 向内存读出或者写入一个内存字
- **写回**， 寄存器文件有两个写端口，其中M用来写访存读出来的值，E用来写ALU计算的结果的值
- **PC更新**， 更新值可以是valP, 是下一条指令的地址；valC,是调用和跳转指令指定的目标地址；也可以是内存中读出来的地址，valM;

![](img/2020-04-30_114434.png)

| 阶段 | 计算                          | OPq rA, rB                                                   | 描述                                                         |
| ---- | ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 取指 | icode:fun; rA, rb; valC; valP | icode:ifun<-- M1[PC]; rA:Rb<-- M1[PC+1]; valC<--M8[PC+8] valp<--PC + 10 | 取得指令代码和功能，寄存器id，取值地址, 立即数，和程序计数器值 |
| 译码 | valA, srcA; valB, srcB        | valA<-- R[rA]; valb<-- R[rB]                                 | 用寄存器id从寄存器文件中读取寄存器值                         |
| 执行 | valE; cond.codes              | valE <-- valB OP valA; Set CC                                | 执行操作并得到valE，设置条件码                               |
| 访存 | Read/Write                    |                                                              | 根据指令需要，从内存中读或写，比如压栈指令会将valA写入栈指针M8[valE] |
| 写回 | E port, destE; M port, dest M | R[rB] <-- valE                                               |                                                              |
| 更新 | PC                            | PC <-- valP                                                  | 根据指令进行特定跳转或者直接写入下一条指令的地址值valP       |



#### SEQ 阶段的实现



**取指**，

![](img/2020-04-30_140727.png)

 根据icode的值，可以计算出三个1位的信号，而后面的字节，

当need_regids为1时，字节1会被分开装入寄存器指示符rA和rB

此时若need_valC为1，字节2~9会被读取为valC

当need_regids为0时，若need_valc为1，字节1~8会被读取为valC

PC增加器根据need_regids 和 need_valC, 改变valP的值



**译码和写回阶段**

![](img/2020-04-30_143908.png)



**执行阶段**

![](img/2020-04-30_152150.png)



根据aluifun信号的设置，对输入aluA和aluB进行ADD, SUBTRACT, AND, EXCLUSIVE-OR运算



**访存阶段**



![](img/2020-04-30_161533.png)

![](img/2020-04-30_161545.png)

![](img/2020-04-30_161556.png)



**更新PC**



------



### 4.4 流水线化的通用原理



#### 计算流水线

将每个指令划分为三个阶段，每个阶段包含一个逻辑组合和一个寄存器访问。



![](img/2020-04-30_163223.png)



#### 流水线操作的详细说明



![](img/2020-04-30_165333.png)



通过插入寄存器，将指令分成多个阶段。因为寄存器是时钟寄存器，当组合逻辑的产生信号后，将信号传递到寄存器，等待时钟上升，始终上升时，寄存器更新值。



**1， 不一致的划分**

时钟周期速率由最慢的阶段限制。当阶段时长分布不均时，时间短的阶段必定要和时间长的阶段对齐，这样总的延迟就变大了



**2. 流水线过深，收益反而下降**

寄存器更新的开销



#### 带反馈的流水线系统



### 4.5 Y86_64的流水线实现

